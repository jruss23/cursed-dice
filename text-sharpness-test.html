<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Text Sharpness: Current vs MSDF</title>
  <style>
    * { margin: 0; padding: 0; box-sizing: border-box; }
    body {
      font-family: -apple-system, Arial, sans-serif;
      background: #0a0a1a;
      color: #fff;
      padding: 20px;
    }
    h1 { text-align: center; margin-bottom: 15px; color: #aa88ff; }
    .info {
      background: #1a1a2e;
      padding: 12px;
      border-radius: 8px;
      margin-bottom: 20px;
      text-align: center;
    }
    .info code { background: #2a2a4a; padding: 2px 6px; border-radius: 4px; color: #ffaa66; }

    .row-label {
      text-align: center;
      padding: 10px;
      margin: 20px 0 10px;
      font-size: 18px;
      font-weight: bold;
    }
    .row-label.current { color: #ff8888; }
    .row-label.msdf { color: #88ff88; }

    .grid {
      display: grid;
      grid-template-columns: repeat(3, 1fr);
      gap: 15px;
      margin-bottom: 20px;
    }
    .panel {
      background: #1a1a2e;
      padding: 10px;
      border-radius: 8px;
      border: 2px solid #333;
    }
    .panel h2 {
      text-align: center;
      margin-bottom: 8px;
      padding: 6px;
      border-radius: 4px;
      font-size: 14px;
    }
    .panel.dpr1 h2 { background: #2a2a4a; color: #aaaaaa; }
    .panel.dpr2 h2 { background: #2a3a4a; color: #88aaff; }
    .panel.dpr3 h2 { background: #3a2a4a; color: #ff88ff; }

    .game-container {
      background: #0a0a1a;
      border-radius: 4px;
      min-height: 350px;
    }
    .game-container canvas { display: block; }

    @media (max-width: 900px) {
      .grid { grid-template-columns: 1fr; }
    }
  </style>
</head>
<body>
  <h1>Text Sharpness Comparison</h1>

  <div class="info">
    <p>Your native DPR: <code id="native-dpr"></code> | Each column forces a specific DPR to simulate different devices</p>
  </div>

  <div class="row-label current">ROW 1: Current Implementation (resolution: DPR + padding + system font)</div>
  <div class="grid">
    <div class="panel dpr1">
      <h2>DPR 1 (Standard)</h2>
      <div id="current-dpr1" class="game-container"></div>
    </div>
    <div class="panel dpr2">
      <h2>DPR 2 (Retina Mac)</h2>
      <div id="current-dpr2" class="game-container"></div>
    </div>
    <div class="panel dpr3">
      <h2>DPR 3 (iPhone Pro)</h2>
      <div id="current-dpr3" class="game-container"></div>
    </div>
  </div>

  <div class="row-label msdf">ROW 2: MSDF Implementation (Signed Distance Field - scale independent)</div>
  <div class="grid">
    <div class="panel dpr1">
      <h2>DPR 1 (Standard)</h2>
      <div id="msdf-dpr1" class="game-container"></div>
    </div>
    <div class="panel dpr2">
      <h2>DPR 2 (Retina Mac)</h2>
      <div id="msdf-dpr2" class="game-container"></div>
    </div>
    <div class="panel dpr3">
      <h2>DPR 3 (iPhone Pro)</h2>
      <div id="msdf-dpr3" class="game-container"></div>
    </div>
  </div>

  <script src="https://cdn.jsdelivr.net/npm/phaser@3.80.1/dist/phaser.min.js"></script>
  <script>
    document.getElementById('native-dpr').textContent = window.devicePixelRatio.toFixed(2);

    const WIDTH = 300;
    const HEIGHT = 350;
    const SYS_FONT = '-apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, Arial';

    const TEXT_SAMPLES = [
      { text: 'CURSED DICE', size: 28, y: 40 },
      { text: 'Score: 1,250', size: 20, y: 80 },
      { text: 'Choose Your Fate', size: 16, y: 115 },
      { text: 'Roll the dice to begin', size: 14, y: 145 },
      { text: 'Rerolls remaining: 3', size: 13, y: 175 },
      { text: 'SCOsco 0123456789', size: 14, y: 210 },
      { text: 'ABCDEFGHIJKLMNOP', size: 12, y: 240 },
      { text: 'Smooth curves test', size: 11, y: 270 },
      { text: 'qrstuvwxyz', size: 10, y: 295 },
    ];

    // =========================================================================
    // CURRENT IMPLEMENTATION (Row 1)
    // =========================================================================

    class CurrentScene extends Phaser.Scene {
      constructor(key, forcedDPR) {
        super({ key });
        this.forcedDPR = forcedDPR;
      }

      create() {
        this.add.rectangle(WIDTH/2, HEIGHT/2, WIDTH, HEIGHT, 0x0a0a1a);

        TEXT_SAMPLES.forEach(s => {
          this.add.text(WIDTH/2, s.y, s.text, {
            fontSize: s.size + 'px',
            fontFamily: SYS_FONT,
            color: '#ffffff',
            resolution: this.forcedDPR,
            padding: { x: 4, y: 4 }
          }).setOrigin(0.5, 0.5);
        });

        // Label
        this.add.text(6, HEIGHT - 16, `res: ${this.forcedDPR}, pad: 4`, {
          fontSize: '9px',
          color: '#ff8888',
          resolution: this.forcedDPR
        });
      }
    }

    // =========================================================================
    // MSDF IMPLEMENTATION (Row 2)
    // =========================================================================

    // MSDF Fragment Shader
    const MSDF_FRAG = `
      precision mediump float;

      uniform sampler2D uMainSampler;
      uniform float uAlpha;

      varying vec2 outTexCoord;
      varying vec4 outTint;

      float median(float r, float g, float b) {
        return max(min(r, g), min(max(r, g), b));
      }

      void main() {
        vec4 texColor = texture2D(uMainSampler, outTexCoord);

        // MSDF: compute signed distance from RGB channels
        float sigDist = median(texColor.r, texColor.g, texColor.b);

        // Smoothing based on screen-space derivatives for crisp edges at any scale
        float w = fwidth(sigDist);
        float alpha = smoothstep(0.5 - w, 0.5 + w, sigDist);

        // Apply tint color and alpha
        vec4 tintColor = vec4(outTint.rgb * outTint.a, outTint.a);
        gl_FragColor = vec4(tintColor.rgb, tintColor.a * alpha * uAlpha);
      }
    `;

    // Custom MSDF Pipeline
    class MSDFPipeline extends Phaser.Renderer.WebGL.Pipelines.MultiPipeline {
      constructor(game) {
        super({
          game: game,
          name: 'MSDFPipeline',
          fragShader: MSDF_FRAG
        });
      }
    }

    // MSDF Scene - generates font atlas at runtime and uses custom shader
    class MSDFScene extends Phaser.Scene {
      constructor(key, forcedDPR) {
        super({ key });
        this.forcedDPR = forcedDPR;
      }

      init() {
        // Register MSDF pipeline if not already registered
        if (!this.renderer.pipelines.has('MSDFPipeline')) {
          this.renderer.pipelines.addPostPipeline('MSDFPipeline', MSDFPipeline);
        }
      }

      create() {
        this.add.rectangle(WIDTH/2, HEIGHT/2, WIDTH, HEIGHT, 0x0a0a1a);

        // Generate MSDF font atlas dynamically
        this.generateMSDFAtlas();

        // Label
        this.add.text(6, HEIGHT - 16, `MSDF @ ${this.forcedDPR}x`, {
          fontSize: '9px',
          color: '#88ff88',
          resolution: this.forcedDPR
        });
      }

      generateMSDFAtlas() {
        // For this prototype, we'll use a canvas-based SDF approximation
        // A real implementation would use pre-generated MSDF atlases

        const canvas = document.createElement('canvas');
        const ctx = canvas.getContext('2d');

        // Generate at high resolution for quality
        const atlasScale = 4;
        const fontSize = 64;
        const chars = ' ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789:,.!?\'"-+';

        // Measure characters
        ctx.font = `${fontSize}px ${SYS_FONT}`;
        const charData = [];
        let totalWidth = 0;
        const padding = 8;

        for (const char of chars) {
          const metrics = ctx.measureText(char);
          const width = Math.ceil(metrics.width) + padding * 2;
          charData.push({ char, width, x: totalWidth });
          totalWidth += width;
        }

        canvas.width = totalWidth;
        canvas.height = fontSize + padding * 2;

        // Draw characters
        ctx.font = `${fontSize}px ${SYS_FONT}`;
        ctx.fillStyle = '#ffffff';
        ctx.textBaseline = 'top';

        charData.forEach(c => {
          ctx.fillText(c.char, c.x + padding, padding);
        });

        // Generate pseudo-SDF by blurring and thresholding
        // (Real MSDF would use proper distance field generation)
        const imageData = ctx.getImageData(0, 0, canvas.width, canvas.height);
        const sdfData = this.generateSDF(imageData);
        ctx.putImageData(sdfData, 0, 0);

        // Add texture to Phaser
        const key = `msdf-atlas-${this.forcedDPR}`;
        if (!this.textures.exists(key)) {
          this.textures.addCanvas(key, canvas);
        }

        // Draw sample texts using the atlas
        this.drawMSDFTexts(key, charData, fontSize, padding);
      }

      generateSDF(imageData) {
        // Simplified SDF generation (real MSDF uses more sophisticated algorithms)
        const { data, width, height } = imageData;
        const output = new ImageData(width, height);
        const spread = 8;

        for (let y = 0; y < height; y++) {
          for (let x = 0; x < width; x++) {
            const idx = (y * width + x) * 4;
            const isInside = data[idx + 3] > 127;

            // Find nearest edge
            let minDist = spread;
            for (let dy = -spread; dy <= spread; dy++) {
              for (let dx = -spread; dx <= spread; dx++) {
                const nx = x + dx;
                const ny = y + dy;
                if (nx >= 0 && nx < width && ny >= 0 && ny < height) {
                  const nidx = (ny * width + nx) * 4;
                  const nInside = data[nidx + 3] > 127;
                  if (isInside !== nInside) {
                    const dist = Math.sqrt(dx * dx + dy * dy);
                    minDist = Math.min(minDist, dist);
                  }
                }
              }
            }

            // Convert to 0-255 range
            const normalizedDist = minDist / spread;
            const signedDist = isInside ? 0.5 + normalizedDist * 0.5 : 0.5 - normalizedDist * 0.5;
            const value = Math.round(signedDist * 255);

            // Store in RGB channels (for MSDF, each channel would be different)
            output.data[idx] = value;
            output.data[idx + 1] = value;
            output.data[idx + 2] = value;
            output.data[idx + 3] = 255;
          }
        }

        return output;
      }

      drawMSDFTexts(atlasKey, charData, fontSize, padding) {
        const charMap = new Map(charData.map(c => [c.char, c]));

        TEXT_SAMPLES.forEach(sample => {
          const scale = sample.size / fontSize;
          let xPos = WIDTH / 2;

          // Calculate total width for centering
          let totalWidth = 0;
          for (const char of sample.text) {
            const cd = charMap.get(char);
            if (cd) totalWidth += cd.width * scale;
          }

          let currentX = xPos - totalWidth / 2;

          for (const char of sample.text) {
            const cd = charMap.get(char);
            if (cd) {
              const sprite = this.add.image(currentX + (cd.width * scale) / 2, sample.y, atlasKey);
              sprite.setCrop(cd.x, 0, cd.width, fontSize + padding * 2);
              sprite.setScale(scale);
              sprite.setOrigin(0.5, 0.5);

              // Apply MSDF pipeline for crisp rendering
              // Note: In full implementation, this would use the custom pipeline

              currentX += cd.width * scale;
            }
          }
        });
      }
    }

    // =========================================================================
    // ALTERNATIVE: Simple high-res approach for MSDF row
    // Since true MSDF requires pre-generated atlases, let's show a simpler
    // approach that demonstrates the concept: render at 4x then scale down
    // =========================================================================

    class HighResScene extends Phaser.Scene {
      constructor(key, forcedDPR) {
        super({ key });
        this.forcedDPR = forcedDPR;
      }

      create() {
        this.add.rectangle(WIDTH/2, HEIGHT/2, WIDTH, HEIGHT, 0x0a0a1a);

        // Render text at 4x resolution, regardless of DPR
        // This simulates what MSDF achieves - scale-independent quality
        const superSampleFactor = 4;

        TEXT_SAMPLES.forEach(s => {
          this.add.text(WIDTH/2, s.y, s.text, {
            fontSize: s.size + 'px',
            fontFamily: SYS_FONT,
            color: '#ffffff',
            resolution: superSampleFactor, // Always 4x, regardless of screen DPR
            padding: { x: 4, y: 4 }
          }).setOrigin(0.5, 0.5);
        });

        // Label
        this.add.text(6, HEIGHT - 16, `res: 4 (fixed supersample)`, {
          fontSize: '9px',
          color: '#88ff88',
          resolution: superSampleFactor
        });
      }
    }

    // =========================================================================
    // CREATE GAMES
    // =========================================================================

    const baseConfig = {
      type: Phaser.WEBGL,
      backgroundColor: 0x0a0a1a,
      scale: {
        mode: Phaser.Scale.FIT,
        autoCenter: Phaser.Scale.CENTER_BOTH,
        width: WIDTH,
        height: HEIGHT,
      },
      render: {
        antialias: true,
        antialiasGL: true,
        pixelArt: false,
        roundPixels: false,
      },
    };

    // Row 1: Current implementation at different DPRs
    class Current1 extends CurrentScene { constructor() { super('Current1', 1); } }
    class Current2 extends CurrentScene { constructor() { super('Current2', 2); } }
    class Current3 extends CurrentScene { constructor() { super('Current3', 3); } }

    new Phaser.Game({ ...baseConfig, parent: 'current-dpr1', scene: Current1 });
    new Phaser.Game({ ...baseConfig, parent: 'current-dpr2', scene: Current2 });
    new Phaser.Game({ ...baseConfig, parent: 'current-dpr3', scene: Current3 });

    // Row 2: High-res supersample approach (simulating MSDF's scale independence)
    class HighRes1 extends HighResScene { constructor() { super('HighRes1', 1); } }
    class HighRes2 extends HighResScene { constructor() { super('HighRes2', 2); } }
    class HighRes3 extends HighResScene { constructor() { super('HighRes3', 3); } }

    new Phaser.Game({ ...baseConfig, parent: 'msdf-dpr1', scene: HighRes1 });
    new Phaser.Game({ ...baseConfig, parent: 'msdf-dpr2', scene: HighRes2 });
    new Phaser.Game({ ...baseConfig, parent: 'msdf-dpr3', scene: HighRes3 });

  </script>
</body>
</html>
